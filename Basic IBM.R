
# Set up info for pollinators ####

# Species info



# Basic array
poll_species<-array(data=0, dim=c(2,5));
colnames(poll_species)<-c("species","interactions","midpoint","scale","efficacy") 

# Add species trait data (interactions will be added later as we are going to reference species in the plant array, so that also needs to be completed)

#Species id
poll_species[, 1]<-seq_len(nrow(poll_species))

#Pollinator efficacy
poll_species[,5]<-sample(seq(from = 0.05, to = 0.8, by=0.05),size=length(poll_species[,3]))

# Coefficients - midpoint
poll_species[,3]<-sample(seq(from = 20, to = 60, by=1),size=length(poll_species[,3]))

# Coefficients - scale
poll_species[,4]<-sample(seq(from = 0.2, to = 0.6, by=0.05),size=length(poll_species[,4]))


## Initialise array for pollinator individuals 

poll        <- array(data = 0, dim = c(20, 8));
colnames(poll) <- c("species","active","dead", "hunger", "maturity", "x_loc", "y_loc", "emergence")


# Set species - when starting up the model for real will need to decide on initial numbers of species and individuals to add to the landscape but for practice purposes I'm just doing 10 of each of the two species

poll[,1]<-rep(1:2, each=1, length.out=20)

#Merge with species info. At the moment this turns it into a df, presumably because I'm using merge? Not sure what the alternatives are 

poll<-merge(poll, poll_species, by = "species")


# Set up plant information ####

# Species info
# Basic array
plant_species<-array(data=0, dim=c(2,5));
colnames(plant_species)<-c("species","interactions", "midpoint","scale", "blank") # At this point I'm adding a blank column in just so there are the same number of columns for plant and pollinator individuals so I don't have to refer to different columns when writing a common function but open to better solutions if they exist

# Add species trait data (interactions will be added later as we are going to reference species in the plant array, so that also needs to be completed)

#Species id
plant_species[, 1]<-seq_len(nrow(plant_species))

# Coefficients - midpoint
plant_species[,3]<-sample(seq(from = 20, to = 60, by=1),size=length(plant_species[,3]))

# Coefficients - scale
plant_species[,4]<-sample(seq(from = 0.2, to = 0.6, by=0.05),size=length(plant_species[,4]))


## Initialise array for plant individuals 

plant        <- array(data = 0, dim = c(20, 8));
colnames(plant) <- c("species","active","dead", "pollinated", "maturity", "x_loc", "y_loc", "emergence")


# Set species - when starting up the model for real will need to decide on initial numbers of species and individuals to add to the landscape but for practice purposes I'm just doing 10 of each of the two species

plant[,1]<-rep(1:2, each=1, length.out=20)

#Merge with species info. At the moment this turns it into a df, presumably because I'm using merge? Not sure what the alternatives are 

plant<-merge(plant, plant_species, by = "species")




# Define emergence function & initialise emergence ####
# Not sure if this is the best way to do this. Currently having to generate a random number column and then apply emergence function using the number from that column. Tried to generate the random number (rand) within the function but couldn't figure out how to stop it generating a single number rather than resample with each row

poll$rand<-runif(length(poll[,1]),0,1)
plant$rand<-runif(length(plant[,1]),0,1)



emergence <- function(poll,midpoint=10,scale=11,rand=13){
  timestep<- poll[,midpoint] - (log((1/poll[,rand])-1)/poll[,scale])
  return(round(timestep, digits=0))
}

poll[,8]<-emergence(poll)
plant[,8]<-emergence(plant)







# Activate individuals according to emergence ####

# Each individual will have an 'emergence' timestep as generated by the emergence function. At each timestep an individual's emergence will be checked against the current timestep. If equal then that individual becomes active and is first placed in the landscape then able to move (if pollinator). A 1 signifies it's ready to be placed ( has emerged onto the landscape). A 2 signifies it has already been placed but is still active (this stops the 'movement' function placing individuals on any timestep past emergence. An alternative would be to just not have individuals move when they first emerge)

activation<- function(inds, active = 2, emergence = 8){
  for(i in 1:dim(inds)[1]){              
  if(inds[i, emergence] == timestep){         # If timestep is equal to emergence
    inds[i, active] <- 1;    # Make individual active ('active' column = 1)
  }
  if(inds[i, emergence] < timestep){         # If timestep is greater than emergence
      inds[i, active] <- 2;    # Make individual active but not placed ('active' column = 2) 
    }
    }
  return(inds)}

    



# Landscape placement and movement ####

# Placement function checks to see if individual is active then, if active, places them in the environment
# x is the size of the landscape x axis, y is the size of the landscape y axis

# Need to figure out how to code this so for plants it checks which locations are already filled as 

placement <- function(inds, x = 50, y = 50, active = 2, x_loc = 6, y_loc = 7){ 
  for(i in 1:dim(inds)[1]){
    if(inds[i, active] == 1){
      inds[i, x_loc]<-sample(x = 1:x, size = 1, replace = TRUE);
      inds[i, y_loc]<-sample(x = 1:y, size = 1, replace = TRUE);
    }
  }
  return(inds)
}

movement <- function(inds, active = 2, x_loc = 6, y_loc = 7, xmax = 50, ymax = 50){
  distance <- c(-2,0,2); # Total movement range
  for(i in 1:dim(inds)[1]){
    if(inds[i, active] == 1 || inds[i, active] == 2){ # For every active individual move its xloc and yloc according to distance sample
      inds[i,x_loc] <- inds[i, x_loc] + sample(x = distance, size = 1);
      inds[i,y_loc] <- inds[i, y_loc] + sample(x = distance, size = 1);
    }
    if(inds[i,x_loc] > xmax){ # If individual has reached end of landscape then put it back to the start (torus landscape)
      inds[i,x_loc] <- inds[i,x_loc] - xmax;
    }
    if(inds[i,y_loc] > ymax){
      inds[i,y_loc] <- inds[i,y_loc] - ymax;
    }
  }
  return(inds)
}
  


# Pollinator interaction ####

# Plant interaction #### 
# 
# Run model ####
timestep<- 23;
time_steps<- 24;



    while(timestep < time_steps){
    poll     <- activation(poll);
    plant    <- activation(plant);
    poll     <- placement(poll);
    plant    <- placement(plant);
    poll     <- movement(poll);
    poll     <- poll[poll[, 3] == 0,]
    plant    <- plant[plant[, 3] == 0,]
    timestep <- timestep + 1; 
}